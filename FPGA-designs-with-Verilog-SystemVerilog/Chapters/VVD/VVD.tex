\chapter{Visual verifications of designs} \label{ch:VisualVerification}
\chapterquote{When divine vision is attained, all appear equal; and there remains no distinction of good and bad, or of high and low.}{Ramakrishna Paramahansa}

\graphicspath{{Chapters/VVD/Figures/}}
\lstinputpath{Codes-Verilog/Chapter-Visual-verifications-of-designs/VerilogCodes} %path is defined in mypreamble


\section{Introduction}
In previous chapters, we saw various elements of Verilog language with some design examples, which were verified using simulations. In this chapter, various smaller units are designed and then combined together to make the large systems. Further, visual verification is performed in this chapter i.e. the designs are verified using LED displays. Finally, in Section \ref{sec:modMCounterVisualTest}, output of mod-$m$ is displayed on various LEDs using smaller designs i.e. counters, clock-ticks and seven segment displays. 

\section{Flip flops}
Flip flops are the sequential circuits which are used  to store 1-bit. In this section, D flip flop is designed with various functionalities in it.

\subsection{D flip flop}
In Listing \ref{verilog:BasicDFF}, the basic D flip flop is designed with reset button. Output of the flip flop is set to zero if reset value is `1', otherwise output has the same value as input. Further, change in the output value occurs during `positive edge' of the clock. Design generated by Listing \ref{verilog:BasicDFF} is shown in Fig. \ref{fig:BasicDFF}.

\begin{explanation} [ Listing \ref{verilog:BasicDFF}]
	In the listing, `d' and `q' are the input and output respectively of the D flip flop. In line 12, output of the D flip flop is set to zero when reset is `1'. In line 9, `$posedge$' is used for checking the `rising edge' of the clock in Verilog i.e. all the statements inside the `always' block will be executed during rising edge of the clock. Next in line 14, input value is sent to the output during the rising edge of the clock.
\end{explanation}
\lstinputlisting[
language = Verilog,
caption    = {Basic D flip flop},
label      = {verilog:BasicDFF}
]{BasicDFF.v}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{BasicDFF}
	\caption{Basic D flip flop, Listing \ref{verilog:BasicDFF}}
	\label{fig:BasicDFF}
\end{figure}

\subsection{D flip flop with Enable port}
Note that, in Fig. \ref{fig:BasicDFF}, the enable button i.e. `ENA' is still not connected. Enable button can be used for allowing the change in the output at desired time instant; e.g. if we want to change the output of the D flip flop on every $10^{th} clock$, then we can set the enable to `1' for every $10^{th} clock$ and `0' for rest of the clocks. We call this as `tick' at every 10 clock cycle; and we will see various examples of `ticks' in this chapter. In this way, we can control the output of the D flip flop. To add the enable functionality in the flip flop, `en == 1' is added in line 13 of Listing \ref{verilog:D_FF}. The design generated by the listing is shown in Fig. \ref{fig:D_FF}

\lstinputlisting[
language = Verilog,
caption    = {D flip flop with enable},
label      = {verilog:D_FF}
]{D_FF.v}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{D_FF}
	\caption{D flip flop with enable, Listing \ref{verilog:D_FF}}
	\label{fig:D_FF}
\end{figure}


\section{Counters}
In this section, two types of counters are designed i.e. binary counter and mod-m counter. 
\subsection{Binary counter}
In Listing \ref{verilog:binaryCounter}, N-bit binary counter is designed which counts the number from 0 to $2^N-1$. After reaching to maximum count i.e. $2^N-1$, it again starts the count from 0.  

\begin{explanation}[Listing \ref{verilog:binaryCounter}]
	In the listing, two output ports are defined i.e. `count' and `complete\_tick', where `complete\_tick' is used to generate tick when the `count' reached to it's maximum value. In line 13, `MAX\_COUNT' is used to define the maximum count for `N' bit counter; where `N' is defined as parameter in line 5. 
	
	Signal `count\_reg' is defined in line 15 and assigned to output at line 31. Value of `count\_reg' is increased by one and assigned to `count\_next' in line 26. Then in next clock cycle, this increased value of `count\_reg' (which is store in `count\_next') is assigned to  `count\_reg' again through line 23. Design generated by the listing is shown in Fig. \ref{fig:binaryCounter}.	
\end{explanation}

\lstinputlisting[
language = Verilog,
caption    = {N-bit binary counter},
label      = {verilog:binaryCounter}
]{binaryCounter.v}

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.7]{binaryCounter}
	\caption{N-bit binary counter, Listing \ref{verilog:binaryCounter}}
	\label{fig:binaryCounter}
\end{figure}

\begin{explanation}[Fig. \ref{verilog:binaryCounter}]
	In the figure, component `Equal0' is generated according to line 29. $32'h00 \cdots 07$ shows that counter is designed with maximum value 7. Output of `Equal0' i.e.  complete\_tick is set to 1 whenever output is equal to maximum value i.e. 7.
	
	`count\_reg[2:0]' shows that three D flip flops are used to create the 3 bit register. Also, we used only `clk' and `reset' ports in the design therefore enable port i.e. `ENA' is unconnected. `Add0' is included in the design to increase the value of count according to line 26. Finally, this increased value is assigned to output port in next clock cycle according to line 23. The simulation waveforms for this design is shown in Fig. \ref{fig:binaryCounterWave}. In the waveforms, we can see that a clock pulse is generated at the end of the count (see `complete\_tick') i.e. `111' in the current example. 
\end{explanation}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{binaryCounterWave}
	\caption{Simulation waveforms of N-bit binary counter, Listing \ref{verilog:binaryCounter}}
	\label{fig:binaryCounterWave}
\end{figure}

\subsection{Mod-$m$ counter}
Mod-$m$ counter counts the values from 0 to (m-1), which is designed in Listing \ref{verilog:modMCounter}. 

\begin{explanation}[Listing \ref{verilog:modMCounter}]
	The listing is same as Listing \ref{verilog:binaryCounter} with some minor changes which are explained here. In line 5, maximum count i.e. M is defined for `Mod-$m$ counter, then in line 6, number for bits `N' is defined which is required to count upto (M-1).
	
	In line 27, count is set to zero, when maximum count is reached otherwise it is increased by 1. Line 30 generates a tick for each count completion. The design generated by the listing is shown in Fig. \ref{fig:modMCounter}.
\end{explanation}
\lstinputlisting[
language = Verilog,
caption    = {Mod-$m$ counter},
label      = {verilog:modMCounter}
]{modMCounter.v}

\begin{explanation}[Fig. \ref{fig:modMCounter}]
	This figure is same as Fig. \ref{fig:binaryCounter} with few changes to stop the count at `M'. Firstly, in `Equal0' component `$32'h0 \cdots 04$' (i.e. `M-1') is used instead of $32'h0 \cdots 07$, as `M' is set to 5 in line 5; and the output of `Equal0' is set to 1 whenever the count reaches to 4. Then output of `Equal0' is sent to the multiplexer `MUX21'; which selects the count $3'h0$ whenever the output of `Equal0' is one, otherwise incremented value (given by `Add0') is sent to the D flip flops. The simulation waveforms for this design is shown in Fig. \ref{fig:modMCounterWave}. In the waveforms, we can see that a clock pulse is generated at the end of the count i.e. `100' (see `complete\_tick) in the current example.
\end{explanation}
\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{modMCounter}
	\caption{Mod-$m$ counter, Listing \ref{verilog:modMCounter}}
	\label{fig:modMCounter}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 1]{modMCounterWave}
	\caption{Simulation waveforms of Mod-$m$ counter, Listing \ref{verilog:modMCounter}}
	\label{fig:modMCounterWave}
\end{figure}

\section{Clock ticks}
In Listing \ref{verilog:clockTick}, Mod-$m$ counter is used to generate the clock ticks of different frequencies, which can be used for operating the devices which work on different clock frequencies. Further, we will use the listing for visual verification of the designs using `LEDs' and `seven segment displays'.

\begin{explanation}[Listing \ref{verilog:clockTick}]
	The listing uses the `Mod-$m$' counter (as shown lines 19-23) to generate the ticks with different time period. In line 8, M = 5 is set, to generate the ticks after every 5 clock cycles as shown in Fig. \ref{fig:clockTickWave}. In the figure, two `red cursors' are used to display the 5 clocks cycles, and during $5^{th}$ cycle the output port i.e. `clkPulse' is set to 1. Further, Fig. \ref{fig:clockTick} shows the structure of the design, whose internal design is defined by Mod-$m$ counter in Listing \ref{verilog:modMCounter}. Lastly, different values of `$M$' and corresponding `$N$' are shown in lines 4-6, to generated the clock ticks of different time periods.
\end{explanation}

\lstinputlisting[
language = Verilog,
caption    = {Generate clocks of different frequencies},
label      = {verilog:clockTick}
]{clockTick.v}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.5]{clockTick}
	\caption{Clock tick generator, Listing \ref{verilog:clockTick}}
	\label{fig:clockTick}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 1]{clockTickWave}
	\caption{Simulation waveforms of clock tick generator, Listing \ref{verilog:clockTick}}
	\label{fig:clockTickWave}
\end{figure}

\section{Seven segment display} \label{sec:sevenSegmentDisplay}
In this section, Verilog code for displaying the count on seven segment display device is presented, which converts the hexadecimal number format (i.e. 0 to F) into 7-segment display format. Further, a test circuit is designed to check the output of the design on the FPGA board. 

\subsection{Implementation}

Listing \ref{verilog:hexToSevenSegment} is designed for active-low seven segment display device, i.e. LEDs of the device will glow if input is `0'. Then, at the end of the design, output is generated for both active low and active high seven segment display devices. 

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.5]{sevenSegmentImage}
	\caption{Seven segment display}
	\label{fig:sevenSegmentImage}
\end{figure}


\begin{explanation}[Listing \ref{verilog:hexToSevenSegment}]
	In the listing, hexadecimal number i.e. `hexNumber' is converted into seven segment format i.e. `sevenSegment'. Lines 13 to 30 perform this conversion e.g. if hexadecimal number is 0 (i.e. "0000" in binary format),  then it is converted into "0000001" in line 14. Since, seven segment display device in the Altera DE2 board is active low, therefore '1' is used in the end (i.e. `$g^{th}$' position is set to `1' in Fig. \ref{fig:sevenSegmentImage}),  so that $7^{th}$ LED will not glow and `0' will be displayed on the seven segment display. 
	
	Since the design is for active low system, therefore in line 33, the signal `sevenSegment' is assigned directly to the output port `sevenSegmentActiveLow'; whereas it is inverted for the active high output port i.e. `sevenSegmentActiveHigh' in line 34. In this way, we can use this design for any kind of devices. In the next section, test circuit is shown for this design.
\end{explanation}
\lstinputlisting[
language = Verilog,
caption    = {Hexadecimal to seven segment display conversion},
label      = {verilog:hexToSevenSegment}
]{hexToSevenSegment.v}

\subsection{Test design for 7 segment display}
Till now, we checked the outputs of the circuits using simulation. In this section, output of the code is displayed on the Seven segment devices which is available on the DE2 FPGA board. Further, we can use the design with other boards as well; for this purpose, the only change required is the pin-assignments, which are board specific.  

Verilog code for testing the design is presented in Listing \ref{verilog:hexToSevenSegment}. Note that, in this listing, we use the names `SW' and `HEX0' etc., which are defined in `DE2\_PinAssg\_PythonDSP.csv' file. Partial view of this file is shown in Fig. \ref{fig:DE2_PinAssg_PythonDSP}, which is provided in the zip folder along with the codes and can be downloaded from the website. This file is used for `pin assignment' in Altera DE2 board. DE2 board provides the 18 switches i.e. SW0 to SW17. Pin number for SW0 is `PIN\_N25', therefore in the `.csv file', we used the name SW[0] for (SW0) and assign the pin number `PIN\_N25' in location column. Note that, we can not change the header names i.e. `To' and `Location' for using the `.csv file'. Further, we can change the names to any other desired names e.g. SW17 is named as `reset', which will be used for resetting the system in later designs. 

For pin assignments with `.csv file', go to \textbf{Assignments$\rightarrow$Import Assignments} and then select the file `DE2\_PinAssg\_PythonDSP.csv'. Next, to see the pin assignments, go to \textbf{Assignments$\rightarrow$Pin Planner}, which will display the pin assignments as shown in Fig. \ref{fig:PinAssignment}. Further, we can manually change the pin location by clicking on the `Location' column in the figure. 

\begin{noNumBox}
	Names `SW' and `HEX0' etc. are used along with `std\_logic\_vector' in the testing circuits, so that pin numbers are automatically assigned to these ports according to `.csv file'. Otherwise we need to manually assign the pin numbers to the ports.
\end{noNumBox}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.9]{DE2_PinAssg_PythonDSP}
	\caption{Partial display of `Pin assignments file' i.e. DE2\_PinAssg\_PythonDSP.csv}
	\label{fig:DE2_PinAssg_PythonDSP}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[scale = 0.9]{PinAssignment}
	\caption{Partial display of Pin Assignments}
	\label{fig:PinAssignment}
\end{figure}

\begin{explanation}[Listing \ref{verilog:hexToSevenSegment_testCircuit}]
	In Line 6 of the listing, 4 bit input port `SW' is defined. Therefore, pin number will be assigned to these switches according to name `SW[0]' to `SW[3]' etc. in the `.csv file'. In line 7, two output ports are defined i.e. HEX0 and HEX1. Next, in line 10 and 13, HEX0 and HEX1 are mapped to active low and active high outputs of the Listing \ref{verilog:hexToSevenSegment} respectively. Note that, it is optional to define all the output ports in the port mapping, e.g. output port `sevenSegmentActiveHigh' is not declared in line 11; whereas all the input ports must be declared in port mapping. 
	
	Now this design can be loaded on the FPGA board as shown in Appendix \ref{QuartusModelsim}. Then, change the switch patterns to see the outputs on the seven segment display devices. Since, HEX0 and HEX1 are set for active low and active high respectively, therefore HEX1 will display the LEDs which are not glowing on the HEX0 e.g. when HEX0 displays the number `8', then HEX1 will not glow any LED as all the LEDs of HEX0 are in the `on' condition. 
\end{explanation}

\lstinputlisting[
language = Verilog,
caption    = {Test design for seven segment display},
label      = {verilog:hexToSevenSegment_testCircuit}
]{hexToSevenSegment_testCircuit.v}


\section{Visual verification of Mod-$m$ counter}\label{sec:modMCounterVisualTest}
In previous section, we displayed the outputs on 7 segment display devices, but clocks are not used in the system. In this section, we will verify the designs with clocks, by visualizing the outputs on LEDs and seven segment displays. Since, 50 MHz clock is too fast to visualize the change in the output with eyes, therefore Listing \ref{verilog:modMCounter_VisualTest} uses the 1 Hz clock frequency for mod-$m$ counter, so that we can see the changes in the outputs. 

\begin{explanation}[Listing \ref{verilog:modMCounter_VisualTest}]
	Since, DE2 provides clock with 50 MHz frequency, therefore it should count upto $5 \times 10^7$ to elapse 1 sec time i.e. $\frac{{50MHz}}{{5 \times {{10}^7}}} = \frac{{50 \times {{10}^6}Hz}}{{5 \times {{10}^7}}} = 1Hz = 1\sec $. Therefore $M=50000000$ is used in line 20.   
	
	In the listing, three component are instantiated i.e. `clockGenerator', `modMCounter' and `hexToSevenSegment' for the visual verification of mod-$m$ counter. Further, counts are verified using both LEDs and seven segment display. In line 20, `clockGenerator' is instantiated which generates the clock of 1 second i.e. `clk\_Pulse1s'. Then this 1 second clock is used by second instantiation i.e. mod-$m$ counter as shown in line 27. This can be seen in Fig. \ref{fig:modMCounter_VisualTest} where output of `clockGenerator' is connect with input clock of mod-$m$ counter. Lastly, all these signals are sent to output port i.e. 1 second clock is displayed by LEDR[0] (line 24), whereas `completed-count-tick' is displayed by LEDR[1] (line 29). Also, counts are displayed by green LEDs i.e. LEDG (line 31).  Further, seven segment display is also instantiated at line 34, to display the count on seven segment display as well. 
\end{explanation}

\lstinputlisting[
language = Verilog,
caption    = {Mod-$m$ counter verification with 1 second clock},
label      = {verilog:modMCounter_VisualTest}
]{modMCounter_VisualTest.v}

\begin{figure}[!h]
	\centering
	\includegraphics[width=\textwidth]{modMCounter_VisualTest}
	\caption{Mod-$m$ counter verification with 1 second clock}
	\label{fig:modMCounter_VisualTest}
\end{figure}

\section{Conclusion}
In this chapter, we designed the circuit which generates various `ticks' of different frequencies. Then the ticks are used for visual verifications of the designs using LEDs and seven segment displays. Further, structural modeling approach is used for the visual verifications of the systems.

